# funcpy Python primitives. Because operators don't come from nowhere.
# Used by standard.fpy.
# Can possibly be improved with a currying decorator.

{{
import inspect

lit = lambda n: lambda: n # literal function
sym_4200 = fpy_multiply = lambda: lambda a: lambda: lambda b: lambda: a () * b ()
sym_4500 = fpy_minus = lambda: lambda a: lambda: lambda b: lambda: a () - b ()
sym_4300 = fpy_plus = lambda: lambda a: lambda: lambda b: lambda: a () + b ()
sym_4700 = fpy_div = lambda: lambda a: lambda: lambda b: lambda: a () / b ()
sym_6200 = fpy_gt = lambda: lambda a: lambda: lambda b: lambda: a () > b ()
sym_6161 = fpy_eq = lambda: lambda a: lambda: lambda b: lambda: a () == b ()
sym_6300 = fpy_choice = lambda: lambda cond: lambda: lambda t: lambda: lambda f: lambda: (
    t () if cond () else f ()
) # ?
fpy_emptylist = lambda: [] # i.e., [] in haskell
sym_5800 = fpy_cons = lambda: lambda x: lambda: lambda xs: lambda: (x, xs) # :
fpy_head = lambda: lambda xs: lambda: xs()[0]()
fpy_tail = lambda: lambda xs: lambda: xs()[1]()
fpy_false = lambda: False
fpy_true = lambda: True

def fpy_dirty_print():
  return fpy_dirty_print1
def fpy_dirty_print1 (a):
  print(printr(a))
  return a
def printr (a, inside = False):
  if type(a ()) is tuple:
    lstr = "%s:%s" % (printr(a()[0],True),printr(a()[1]))
    return "(%s)" % lstr if inside else lstr
  else: return a ()

# algebraic Types

class Type(object):
  def __init__(self, option, **values):
    self.option = option
    self.values = values
  def isa(self, option):
    print(self.option, option())
    return lambda: self.option == option()
  def value(self, n):
    return lambda: self.values[n()]()
fpy_isa = lambda: lambda type: lambda: lambda option: lambda: type().isa(option)()
fpy_get = lambda: lambda type: lambda: lambda value: lambda: type().value(value)()
}}
